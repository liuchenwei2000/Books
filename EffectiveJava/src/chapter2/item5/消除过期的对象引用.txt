                                                                       消除过期的对象引用


如果一个对象引用被无意识的保留起来了，那么垃圾回收机制不仅不会处理这个对象，而且也不会处理被这个对象引用的所有其他对象。
即使只有少量的几个对象引用被无意识的保留下来，也会有很多的对象被排除在垃圾回收机制之外，从而对性能造成潜在的重大影响。

要想修复这一类问题很简单，一旦对象引用已经过期，只需清空这些引用即可(或者重用此引用，让其指向别的对象)。

清空过期引用的另一个好处是，如果它们在以后又被错误的引用，就会立即抛出空指针异常。

一般而言，只要一个类自己管理它的内存，就应该警惕内存泄漏问题。一旦一个元素被释放掉，则该元素中包含的任何对象引用应该要被清空。

内存泄漏的另一个常见来源是缓存，一旦把一个对象引用放到一个缓存中，它就很容易被遗忘掉，从而使得它不再有用之后很长一段时间内仍然留在缓存中。
对于这个问题，有两种可能的解决方案：
1，如果你正巧要实现这样的缓存：
只要在缓存之外存在对某个条目的键的引用，该条目就有意义，那么可以使用WeakHashMap来代表缓存；
当缓存中的条目过期之后，它们自动被删除。
2，“被缓存的条目是否有意义”的周期并不很容易确定，其中的条目会在运行的过程中变得越来越没有价值。
此时，缓存应该时不时地清除掉无用的条目。这项清除工作可以由一个后台线程(定时器Timer)来完成，或者也可以在加入新条目的时候做清理工作。
LinkedHashMap类的removeEldestEntry方法可以很容易地实现此方案。
