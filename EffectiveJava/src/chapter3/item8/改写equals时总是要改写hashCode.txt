                                                           改写equals时总是要改写hashCode

在每个改写了equals方法的类中，必须也要改写hashCode方法。
如果不这样做，就会违反Object.hashCode的通用约定，从而导致该类无法与所有基于散列值(hash)的集合类结合在一起正常工作。

hashCode的规范约定：

1，在一个应用程序执行期间，如果一个对象的equals方法作比较所用到的信息没有被修改的话，
那么对该对象调用hashCode方法多次，它必须始终如一的返回同一个整数。
在同一个应用程序的多次执行过程中，这个整数可以不同，即这个应用程序这次执行返回的整数与下一次执行返回的整数可以不一致。
2，如果两个对象根据equals方法是相等的，那么调用这两个对象中任一个对象的hashCode方法必须产生相同的整数结果。
3，如果两个对象根据equals方法是不相等的，那么调用这两个对象中任一个对象的hashCode方法，不要求必须产生不同的整数结果。
然而，必须意识到这样的事实，对于不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。

根据第二条约定，所以要在改写equals时总是要改写hashCode，以便相等的对象有相等的散列值。
根据一个类的equals方法，两个不同的实例有可能在逻辑上是相等的。但根据Object类的hashCode方法，它们仅仅是两个对象，没有其他共同的地方。
因此，对象的hashCode方法返回两个看起来是随机的整数，而不是相等的整数。

一个好的散列函数倾向于“为不相等的对象产生不相等的散列码”。
理想情况下，一个散列函数应该把一个集合中不相等的实例均匀的分布到所有可能的散列值上。
要想完全达到这种理想的情形是非常困难的，相对接近这种理想情形并不困难。

下面是简单的处方：

1，把某个非零常数值，比如说17，保存在一个叫result的int类型的变量中。
2，对于对象中每一个关键域f(指equals方法中考虑到的每一个域)，完成以下步骤：
 a，为该域计算int类型的散列码c：
   1，如果该域是boolean类型，则计算(f ? 0 : 1)。
   2，如果该域是byte、char、short或者int类型，则计算(int) f。
   3，如果该域是long类型，则计算(int) (f ^ (f >>> 32))。
   4，如果该域是float类型，则计算Float.floatToIntBits(f)。
   5，如果该域是double类型，则计算Double.doubleToLongBits(f)得到一个long类型的值，然后按照步骤 2.a.3，对该long值计算散列值。
   6，如果该域是一个对象引用，并且该类的equals方法通过递归调用equals的方式来比较这个域，则同样对这个域递归调用hashCode。
               如果这个域的值为null，则返回0(或者是其他常数，习惯用0)。
   7，如果该域是一个数组，则把每一个元素当做单独的域来处理。
              也就是说，递归地应用上述规则，对每个重要的元素计算一个散列码，然后根据步骤2.b中的做法把这些散列值组合起来。
 b，按照下面的公式把步骤a中计算得到的散列码c组合到result中：
    result = 37 * result + c;
3，返回result。
4，写完hashCode之后，确认是否相等的实例具有相等的散列码。

如果一个域的值可以根据参与计算的其他域值计算出来(即冗余域)，则把这样的域排除在外是可以接受的。
对于在相等比较计算中没有被用到的任何域，要把它们排除在外，这是一个要求。
