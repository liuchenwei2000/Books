                                                                       用类代替enum结构


C语言中的enum结构类似于用常量来实现一个枚举类型，Java中也可以利用这个方式做到这一点，示例见chapter5.item21.PlayingCard.java。
这个示例模式的一个变形是使用String常量来实现枚举类型，要避免这么做。
虽然它为这些常量提供了可打印的字符串，但是它会导致性能问题，因为它依赖于字符串的比较操作。
而且它会导致初级用户采用硬编码的方式使用枚举常量。


Java提供了另一种方案，可以避免常见的int和String模式的所有缺点，并且还有额外的好处。这种方案被称为类型安全枚举(typesafe enum)模式。
基本想法：定义一个类来代表枚举类型的单个元素，并且不提供任何公有的构造函数。相反，提供公有的静态final域，使枚举类型中的每一个常量都对应一个域。
示例见chapter5.item21.Suit.java。
(Java在5.0版本中已经加入了对类型安全枚举的原生支持，直接声明某个类为enum即可，示例见chapter5.item21.SuitEnum.java)


类型安全枚举模式提供了编译时的类型安全性。如果声明一个方法，它的一个参数为Suit类型，则可以保证任何传入的非null对象引用一定表示了这四种纸牌花色之一。
企图传递一个类型不正确的对象将会在编译的时候被捕捉到。


新的常量可以被加入到一个类型安全枚举类中，而无需重新编译客户代码，因为包含枚举常量的公有静态对象引用域为客户端和枚举类之间提供了一层隔离层。
常量本身并没有被编译到客户端代码中，而在更常见的int模式和String模式中，常量被编译到客户代码中。


更一般的，可以再类型安全枚举类中增加一些适当的方法，以此壮大这样的类。
一个类可以从最简单的类型安全枚举类开始，随时间的推移逐步演化为一个具有全面特性的抽象。示例见chapter5.item21.Suit2.java。


若一个枚举只被用于包含该类的包中，对于这样的常量，也许会有一个或者多个行为与它相关联。这样的行为最好作为该类的包级私有方法来实现。
于是每个枚举常量都支持一组隐藏的行为，这使得包含该枚举类的包在看到这样的常量的时候可以采取适当的动作。示例见chapter5.item21.Operation。


类型安全枚举类在性能上可以与int枚举常量相媲美，客户可以使用==操作符，来代替equals方法，而且可以保证两者的结果是相同的，并且==可能会更快一些。


如果一个类型安全枚举类具有普遍适用性，那么它应该成为一个顶层类；如果它只是被用在一个特定的顶层类中，那么它应该成为顶层类的一个静态成员类。


对于任何枚举类型的需求都应该相对较少，因为随着子类化技术的推广，这些类型的主要用途已经过时了。
