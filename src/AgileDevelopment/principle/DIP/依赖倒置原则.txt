                                                                                  依赖倒置原则(Dependency Inversion Principle)


依赖倒置原则(DIP)：
a，高层模块不应该依赖于低层模块，二者都应该依赖于抽象。
b，抽象不应该依赖于细节，细节应该依赖于抽象。


倒置的含义：
由于许多传统的软件开发方法，比如结构化的分析和设计，总是倾向于创建一些高层模块依赖于低层模块。策略依赖于细节的软件结构。
实际上这些方法的目的之一就是要定义子程序的层次结构，该层次结构描述了高层模块怎样调用低层模块。
一个设计良好的面向对象的程序，其依赖程序结构相对于传统的过程式方法设计的通常结构而言就是被倒置了。


当高层模块依赖于低层模块时意味着什么？
高层模块包含了一个应用程序中的重要的策略选择和业务模型，如果这些高层模块依赖于低层模块，
那么对低层模块的改动就会直接影响到高层模块，从而迫使它们依次做出改动。

这种情形是很荒谬的：
1，本应该是高层的策略设计模块去影响低层的细节实现模块的。
包含高层业务规则的模块应该优先并独立于包含实现细节的模块。无论如何高层模块都不应该依赖于低层模块。
2，我们更希望能够重用的是高层的策略设计模块。我们已经非常擅于通过子程序库的形式来重用低层模块。
如果高层模块依赖于低层模块，那么在不同的上下文中重用高层模块就会变得非常困难。
然而，如果高层模块独立于低层模块，那么高层模块就可以非常容易的被重用。该原则是框架设计的核心原则。


层次化

所有结构良好的面向对象框架都具有清晰的层次定义，每个层次通过一个定义良好的、受控的接口向外提供了一组内聚的服务。

合适的设计是这样的：
每个较高层次都为它所需要的服务声明一个抽象接口，较低的层次实现了这些抽象接口，每个高层类都通过该抽象接口使用下一层，
这样高层就不依赖于低层，低层反而依赖于在高层中声明的抽象服务接口，从而解除了高层对低层的依赖关系。

注意这里的倒置不仅仅是依赖关系的倒置，它也是接口所有权的倒置。我们通常会认为工具库应该拥有它们自己的接口。
但是当应用了DIP时，我们发现往往是客户拥有抽象接口，而它们的服务者则去实现这些抽象接口。

低层模块实现了在高层模块中声明并被高层模块调用的接口。
通过这种倒置的接口所有权，对于低层模块的任何改动都不会再影响到高层模块。
而且高层模块可以在定义了符合其接口的任何上下文中重用。
这样，通过倒置这些依赖关系，我们创建了一个更灵活、更持久、更易改变的结构。


依赖于抽象

一个简单但仍然非常有效的对于DIP的解释，是这样一个简单的启发式规则：依赖于抽象。
该规则建议不应该依赖于具体类——也就是说，程序中所有的依赖关系都应该终止于抽象类或接口。
即：
1，任何变量都不应该持有一个指向具体类的引用。
2，任何类都不应该从具体类派生。
3，任何方法都不应该覆盖它的任何基类中的已经实现了的方法。

当然每个程序中都会有违反该启发规则的情况。有时必须要创建具体类的实例，而创建这些实例的模块将会依赖于它们。
对于那些虽是具体但却稳定的类来说不太合理，如果一个具体类不太会改变，并且也不会创建其他类似的派生类，那么依赖于它并不会造成伤害。比如Java中的String类。

然而我们在应用程序中所编写的大多数具体类都是不稳定的。我们不想直接依赖于这些不稳定的具体类。
通过把它们隐藏在抽象接口后面，可以隔离它们的不稳定性。这不是一个完美的解决方案。
常常如果一个不稳定类的接口必须要变化时，这个变化一定会影响到表示该类的抽象接口。这种变化破坏了由抽象接口维系的隔离性。
另一方面，可以认为是由客户类来声明它们所需要的服务接口，那么仅当客户需要时才会对接口进行改变。
这样，改变实现抽象接口的类就不会影响到客户类了。

依赖倒置可以应用于任何存在一个类向另一个类发送消息的地方。什么是高层策略？
它是应用背后的抽象，是那些不随具体细节的改变而改变的真理。
它是系统内部的系统，在ButtonLamp例子中，背后的抽象是检测开关指令并将指令传递给目标对象。
至于用什么机制检测、目标对象是什么都无关紧要，这些都是不会影响到抽象的具体细节。

依赖倒置原则是实现许多面向对象技术所宣称的好处的基本低层级制。它的正确应用对于创建可重用的框架来说是必须的。
同时它对于构建在变化面前富有弹性的代码也是非常重要的。由于抽象和细节被彼此分离，所以代码也非常容易维护。
