                                         里氏替换原则(Liskov Substitution Principle)


里氏替换原则(OCP)：子类型(subtype)必须能够替换掉它们的基类型(basetype)。

假设有一个函数f，它的参数是某个基类B。同样假设有B的某个派生类D，如果把D的对象作为B类型传递给f，
会导致f出现错误的行为。那么D就违反了LSP，并且D对于f来说是脆弱的。
f的编写者会想去对D进行一些测试，以便于在把D的对象传递给f时，可以使f具有正确的行为。
这个测试违反了OCP，因为此时f对于B的所有不同的派生类都不再是封闭的。

对于LSP的违反常常会导致以明显违反OCP的方式使用运行时类型识别(RTTI)。
这种方式常常是使用一个显式的if语句或者if/else去确定一个对象的类型，以便于可以选择针对该类型的正确行为。

通过RectangleSquareDemo，LSP让我们得出一个非常重要的结论：
一个模型，如果孤立地看，并不具有真正意义上的有效性。模型的有效性只能通过它的客户程序来表现。
在考虑一个特定设计是否恰当时，不能完全孤立的来看这个解决方案。必须要根据该设计的使用者所做出的合理假设来审视它。
这些合理的假设常常以断言的形式出现在为基类编写的单元测试中，这又是一个要测试驱动开发的好理由。


is-a是关于行为的
再看RectangleSquareDemo，难道正方形不是一个矩形么？
对于那些不是Area.test()的编写者而言，正方形可以是长方形，但从test()的角度看，Squeare对象绝对不是Rectangle对象。
从行为方式的角度看，正方形不是矩形，对象的行为方式才是软件真正所关注的问题。
LSP清楚地指出，OOD中的is-a关系是就行为方式而言的，行为方式是可以进行合理假设的，是客户程序所依赖的。

一些规则可以提供有关违反LSP的提示
1，完成的功能少于其基类的派生类通常是不能替换其基类的，因此就违反了LSP。
2，在派生类的方法中添加了其基类不会抛出的异常。
如果基类的使用者不期望这些异常，那么就把它们添加到派生类的方法中就会导致不可替换性。


LSP是使OCP成为可能的主要原则之一，正是子类型的可替换性才使得使用基类类型的模块在无需修改的情况下就可以扩展，这种可替换性必须是开发人员可以隐式依赖的东西。