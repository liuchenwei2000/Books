                                                                                                开闭原则(Open-Closed Principle)


开闭原则(OCP)：软件实体(类、模块、函数等等)应该是可以扩展的，但是不可修改的。

如果程序中的一处改动就会产生连锁反应，导致一系列相关模块的改动，那么设计就具有僵化性的臭味。
OCP建议我们应该对系统进行重构，这样以后对系统再进行那样的改动时，就不会导致更多的修改。
如果正确的应用OCP，那么以后再进行同样的改动时，就只需要添加新的代码，而不必改动已经正常运行的代码。


遵循开闭原则设计出的模块具有两个主要的特征：
1，对于扩展是开放的
这意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。换句话说，我们可以改变模块的功能。
2，对于更改是封闭的
对模块行为进行扩展时，不必改动模块的源代码或者二进制代码。模块的二进制可执行版本，无论是dll还是jar文件都无需改动。


这两个特征好像是互相矛盾的。扩展模块行为的通常方式就是修改该模块的源代码，不允许修改的模块常常都被认为是具有固定的行为。


怎样可能在不改动模块源代码的情况下去更改它的行为呢？关键是抽象！
在任何OOP语言中，可以创建出固定却能够描述一组任意个可能行为的抽象体。这个抽象体就是抽象基类(或接口)，而这一组任意个可能的行为则表现为可能的派生类。
模块可以操作一个抽象体，由于模块依赖一个固定的抽象体，所以它对于更改可以是关闭的，同时，通过从这个抽象体派生，也可以扩展此模块的行为。


如果我们预测到了某种变化，那么就可以设计一个抽象来隔离它。一般而言，无论模块是多么的封闭，都会存在一些无法对之封闭的变化。
没有对于所有的情况都贴切的模型。既然不可能完全封闭，那么就必须有策略的对待这个问题。
设计人员必须对他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化的种类，然后构造抽象来隔离这些变化。
这需要设计人员具备一些从经验中获得的预测能力。有经验的设计人员希望自己对用户和应用领域很了解，能够以此来判断各种变化的可能性。
然后，他们可以让设计对于最有可能发生的变化遵循OCP原则。

这一点不容易做到，因为它意味着要根据经验猜测那些应用程序在生长历程中有可能遭受的变化。
如果开发人员猜测正确，就能获得成功，否则就会遭受失败。并且在大多情况下，他们都会猜测失败。

同时，遵循OCP的代价也是昂贵的。创建正确的抽象是要花费开发时间和精力的。
那些抽象也增加了软件设计的复杂性。显然，我们希望把OCP的应用限定在可能发生的变化上。

如何知道哪个变化有可能发生呢？我们进行适当的调查，提出正确的问题，并且使用我们的经验和一般常识。
最终，我们会一直等到变化发生时才采取行动。

为了防止软件背着不必要的复杂性，我们会允许自己被愚弄一次。这意味着我们最初编写代码时，假设变化不会发生。
当变化发生时，我们就创建抽象来隔离以后发生的同类变化。这是一种有效地对待软件设计的态度。

我们希望在开发工作展开不久就知道可能发生的变化，查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难。
因此，我们需要去刺激变化：
1，首先编写测试。
测试描绘了系统的一种使用方法。通过首先编写测试，我们迫使系统成为可测试的。
在一个具有可测试性的系统中发生变化时，我们可以坦然处之。因为我们已经构建了使系统可测试的抽象。
并且通常这些抽象中的许多都会隔离以后发生的其他种类的变化。
2，使用很短的迭代周期进行开发——一个周期是几天而不是几周。
3，在加入基础结构前就开发特性，并且经常性的把那些特性展示给涉众。
4，首先开发最重要的特性。
5，尽早的、经常性的发布软件，尽可能快的、频繁的把软件展示给客户和使用人员。


OCP是面向对象设计的核心。遵循这个原则可以带来面向对象技术所声称的巨大好处(即灵活性、可重用性以及可维护性)。
对于应用程序中的每个部分都肆意的进行抽象同样不是一个好主意。
正确的做法是，开发人员应该仅仅对程序中呈现出频繁变化的那些部分做出抽象。拒绝不成熟的抽象和抽象本身一样重要。
