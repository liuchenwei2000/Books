                                                                                    接口隔离原则(Interface Segregation Principle)


这个原则用来处理胖(fat)接口所具有的缺点。如果类的接口不是内聚的，就表示该类具有胖的接口。
换句话说，类的胖接口就可以分解成多组方法。每一组方法都服务于一组不同的客户程序。
这样，一些客户程序可以使用一组方法，而其他客户程序可以使用其他组的方法。

ISP承认存在一些对象，它们确实不需要内聚的接口；但是ISP建议客户程序不应该看到它们作为单一的类的存在。
相反，客户程序看到的应该是多个具有内聚接口的抽象基类(Java接口)。


接口污染：接口变胖的原因

有时在抽象基类(接口)加入一个方法只是为了能给它的一个子类带来好处，如果持续这样做的话，
那么每次子类需要一个新方法时，这个方法就会被加到基类中去。这会进一步污染基类的接口，使它变胖。
此外，每次基类中加入一个方法时，派生类中就必须要实现这个方法(或者定义一个缺省实现)。

分离客户就是分离接口

既然客户程序是分离的，所以接口也应该是保持分离。因为客户程序对它们使用的接口施加有作用力。
在我们考虑软件中引起变化的作用力时，通常考虑的都是接口的变化会怎样影响它们的使用者。
然而存在着从另外一个方向施加的作用力。有时，迫使接口改变的，正是它们的使用者。


接口隔离原则(ISP)：不应该强迫客户依赖于它们不用的方法。

如果强迫客户程序依赖于那些它们不使用的方法，那么这些客户程序就面临着由于这些未使用方法的改变所带来的变更。
这无意中导致了所有客户程序之间的耦合。也就是说，如果一个客户程序依赖于一个含有它不是用的方法的类，
但是其他客户程序却要使用该方法，那么当其他客户要求这个类改变时，就会影响到这个客户程序，并且更改的代价和影响就变得不可预测。
我们希望尽可能的避免这种耦合，因此希望分离接口。


对客户进行分组

常常可以根据客户所调用的服务方法来对客户进行分组。这种分组方法使得可以为每组而不是每个客户创建分离的接口。
这极大地减少了服务需要实现的接口数量，同时也避免了让服务依赖于每个客户类型。
有时，不同的客户组调用的方法会有重叠。如果重叠部分较少，那么组的接口应该保持分离。公用的方法应该在所有有重叠的接口中声明。
服务者类会从这些接口的每一个中继承公用的方法，但是只实现它们一次。


改变接口

在维护面向对象的应用程序时，常常会改变现有类和组件的接口。
通常这些改变都会造成巨大的影响，并且迫使系统的绝大部分需要重新编译和部署。
这种影响可以通过为现有的对象增加新接口的方法来缓解，而不是去改变现有的接口。
原有接口的客户如果想访问新接口中的方法，可以通过对象去访问该接口。
示例见：principle.ISP.v1.InterfaceChangeDemo


胖类会导致它们的客户程序之间产生不正常的并且有害的耦合关系。
当一个客户程序要求该胖类进行一个改动时，会影响到所有其他的客户程序。
因此，客户程序应该仅仅依赖于它们实际调用的方法。通过把胖类的接口分解成多个特定于客户程序的接口，可以实现这个目标。
每个特定于客户程序的接口仅仅声明它的特定客户或者客户组调用的那些函数。
接着，该胖类就可以继承所有特定于客户程序的接口，并实现它们。
这就解除了客户程序和它们没有调用的方法间的依赖关系，并使客户程序之间互不依赖。