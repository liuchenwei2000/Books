                                                           在改写equals的时候要遵循通用约定

不需要改写equals方法的情况：

1，一个类的每个实例本质上都是唯一的。
对于代表了活动实体而不是值(value)的类，确实如此。比如Thread。
2，不关心一个类是否提供了“逻辑相等”的测试功能。
3，超类已经改写了equals，从超类继承过来的行为对于子类也是合适的。
4，一个类是私有的，或者是包级私有的，并且可以确定它的equals方法永远也不会被调用。
尽管如此，也应该改写equals方法如下，以免万一有一天它被调用到：
public boolean equals(Object o) {
  throw new UnsupportedOperationException();
}


需要改写equals方法的情况：

当一个类有自己特有的“逻辑相等”概念(不同于对象身份的概念)，而且超类也没有改写equals以实现期望的行为，这时需要改写equals方法。
这通常适合于“值类(value class)”的情形，比如Integer或者Date。
程序员在利用equals方法来比较两个指向值对象的引用的时候，希望知道它们逻辑上是否相等，而不是是否指向同一个对象。
为了满足这个要求，改写equals方法是必需的，而且这样做也使得这个类的实例可以被用做映射表的键，或者集合的元素，并使映射表和集合表现出预期的行为。

有一种值类可以不要求改写equals方法，即类型安全枚举。因为类型安全枚举保证每一个值至多只存在一个对象
，所以对于这样的类而言，Object的equals方法等同于逻辑意义上的equals方法。


根据规范，equals方法需要实现如下等价关系：
1，自反性。对任意的引用值x，x.equals(x)一定返回true。
2，对称性。对任意的引用值x和y，x.equals(y)和y.equals(x)结果必须一致。
3，传递性。对任意的引用值x、y、z，如果有x.equals(y)返回true，y.equals(z)返回true，则x.equals(z)一定返回true。
4，一致性。对任意的引用值x和yequals比较的对象信息没有被修改的话，无论调用多少次x.equals(y)返回结果保持一致。
5，对任何不是null的引用值x，x.equals(null)一定返回false。


实现高质量的equals方法的一个处方：
1，使用==操作符检查“实参是否为指向相同对象的一个引用”。
如果是的话则返回true，这只不过是一种性能优化，如果比较操作有可能非常耗时的话，这样做是值得的。
2，使用instanceof操作符检查“实参是否为正确的类型”。
如果不是的话，则返回false。通常这里“正确的类型”是指equals方法所在的那个类。有些情况下，是指该类所实现的某个接口。
如果一个类实现的一个接口改进了equals约定，允许在实现了该接口的类之间进行比较，那么使用这个接口作为正确的类型。集合接口如List、Set具有这样的特点。
3，把实参转换到正确的类型。
4，对于该类中的每一个关键域，检查实参中的域与当前对象中对应的域值是否匹配。如果所有的测试都成功，则返回true，否则返回false。
域的比较顺序可能会影响到equals方法的性能，为了获得最佳性能，最先进行比较的域应该是最有可能不一致的域，或者是比较开销最低的域。
5，当完成equals方法之后，应该看其：是否是对称的、传递的、一致的。

下面是一些告诫：
1，当改写equals的时候，总是要改写hashCode。
2，不要企图让equals方法过于聪明。如果想过度的去寻求各种等价关系，则很容易陷入麻烦中。
3，不要使equals方法依赖于不可靠的资源。它应该针对驻留在内存中的对象执行确定性的计算而不是网络或者DB。
4，不要将equals声明中的Object对象替换为其他的类型。那样只是重载(overload)而不是覆盖(override)。
public boolean equals(MyClass o){
  // ...
}