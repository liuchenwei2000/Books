                                                             使类和成员的可访问能力最小化


一个设计良好的模块会隐藏所有的实现细节，包括内部的数据和其他的实现细节，把它的API与实现清晰地隔离开来。
然后，模块之间只通过它们的API进行通信，一个模块不需要知道其他模块的内部工作情况。
这个概念被称为信息隐藏，或者封装，是软件设计的基本原则之一。

信息隐藏的主要理由：
1，它可以有效地解除一个系统中各模块之间的耦合关系，使得这些模块可以被独立的开发、测试、优化、使用、理解和修改。
2，可以提高软件的可重用性，因为单独的模块并不依赖于其他的模块。
3，降低了构建大型系统的风险；即使整个系统并不成功，这些独立的模块也有可能是成功的。

Java通过访问控制做到信息隐藏，它决定了类、接口和成员的可访问性。
一个实体的可访问性是由该实体声明时所在的位置，以及该实体声明中所出现的访问修饰符(private、protected和public)共同决定的。

经验表明，应该尽可能的使每一个类或成员不被外界访问。应该使用最低可能的、并且与该软件的正确功能相一致的访问级别。

对于顶层的(非嵌套的)类和接口，它们只有两种可能的访问级别：包级私有的和公有的。
通过把一个类或者接口做成包级私有的，它实际上成了这个包的实现的一部分，而不是该包导出的API的一部分；
并且，在以后的版本中，可以对它进行修改、替换或者删除，而无需担心会伤害到现有的客户。
如果把它做成公有的，就有责任永远支持它，以保持兼容性。

对于成员(域、方法、嵌套类和嵌套接口)有四种可能的访问级别：

1，私有的 private
只有在声明该成员的顶层类内部才可以访问这个成员。

2，包级私有的 package-private
声明该成员的包内部的任何类都可以访问这个成员。

3，受保护的 protected
该成员声明所在类的子类可以访问这个成员，并且该成员所在包内部的任何类也可以访问这个成员。

4，公有的 public
任何地方都可以访问该成员。


几点需要注意的地方：

1，私有成员和包级私有成员都是一个类的实现中的一部分，并不会影响其他导出的API。
然而，如果这些域所在的类实现了Serializable接口，那么这些域可能会被泄露到导出的的API中。

2，受保护的成员是一个类的导出的API的一部分，必须永远被支持。
一个导出的类的每一个受保护的成员代表了该类对于一个实现细节的公开承诺。受保护的成员应该尽量少用。

3，公有类应该尽可能少的包含公有的域(相对于公有的方法)。
这个规则有个例外，通过公有的静态final域来暴露类的常量是允许的。按照惯例，这样的域的名字由大写字母组成，单词之间用下划线隔开。
很重要的一点是，这些域要么包含原语类型的值，要么包含指向非可变对象的引用。
如果一个final域包含一个指向可变对象的引用，那么它具有非final域的所有缺点。虽然引用本身不能被修改，但是它引用的对象可以被修改。
所以，具有公有的静态final数组域几乎总是错误的。如果一个类包含这样的一个域，客户将能够修改数组中的内容：

public static final Type[] VALUES = {...};

替代的解决方案有：
公有数组应该被替换成一个私有数组，以及一个公有的非可变列表：

private static final Type[] VALUES_ARRAY = {...};
public static final List<Type> VALUES = Collections.unmodifiableList(Arrays.asList(VALUES_ARRAY));


总结：应该总是尽可能的降低可访问性。
在仔细的设计了一个最小的公有API之后，应该防止把任何杂散的类、接口和成员变成API的一部分。
除了公有静态final域的特殊情形之外，公有类不应该包括公有域；并且确保公有静态final域所引用的对象是不可变的。
