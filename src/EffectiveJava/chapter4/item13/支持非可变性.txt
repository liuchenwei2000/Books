                                                             支持非可变性


一个非可变类是一个简单的类，它的实例不能被修改。
每个实例中包含的所有信息都必须在该实例被创建的时候就提供出来，并且在对象的整个生存期内固定不变。
非可变类比可变类更加易于设计、实现和使用。它们不容易出错，更加安全。

为了使一个类成为非可变类，要遵循下面五条规则：

1，不要提供任何会修改对象的方法。

2，保证没有可被子类改写的方法。
这可以防止粗心的或者恶意的子类破坏该类的不可变行为。

3，使所有的域都是final的。
通过系统的强制方式，这可以清楚地表明你的意图。

4，使所有的域都成为私有的。
这样可以防止客户直接修改域中的信息。
虽然非可变类可以具有公有的final域，只要这些域包含原语类型的值或者指向非可变对象的引用，从技术上是允许的，但是不值得提倡，违反了封装性。

5，保证对于任何可变的组件的互斥访问。
如果类中具有指向可变对象的域，则必须确保该类的客户无法获得指向这些对象的引用。
并且永远不要用客户提供的对象引用来初始化这样的域，也不要在任何一个访问方法中返回该对象引用。

示例见chapter4.item13.ComplexNumber.java。


非可变对象的一些优点：

1，非可变对象比较简单。
一个非可变对象可以只有一个状态，即最初被创建时刻的状态。
如果你能够确保所有的构造函数都建立了这个类的约束关系，那么可以保证这些约束关系在整个生命周期内永远不再发生变化，
无需你和使用这个类的程序员再做额外的工作来维护这些约束关系。

2，非可变对象本质上是线程安全的，它们不要求同步。
当多个线程并发访问这样的对象时，它们不会被破坏。

3，非可变对象可以被自由的共享。
要鼓励客户尽可能的重用已有的实例，一个很简单的办法，对于频繁被用到的值，为它们提供共有的静态final常量。示例见chapter4.item13.ComplexNumber.java。
也可以进一步扩展为提供一些静态工厂，它们把频繁被用到的实例缓存起来，从而当请求一个预先存在的实例的时候，可以不再创建新的实例，从而降低内存占用和垃圾回收的代价。

4，第3点导致的一个结果是：永远也不需要进行保护性拷贝。
实际上根本不需要做任何拷贝，因为这些拷贝始终等于原始的对象。因此，不需要也不应该为非可变类提供clone方法或者拷贝构造函数。

5，非可变对象真正惟一的缺点是，对于每一个不同的值都要求一个单独的对象。
创建这样的对象可能会代价很高，特别是对于大型对象的情形。如果执行一个多步骤的操作，并且每个步骤都会产生一个新的对象，
除了最后的结果之外其他的对象最终都会被丢弃，那么此时性能问题就会被暴露出来。
为此最好的办法是提供一个公有的可变配套类。在JDK中，String是不可变类，而StringBuffer就是它的可变配套类。


对于第二条原则：保证没有可被子类改写的方法。实现方法主要有三种：

1，使一个类成为final的。
2，让一个类的每一个方法都成为final的。
3，使类所有的构造函数都是私有的，或者包级私有的，并且增加公有的静态工厂来代替公有的构造函数。示例见.java。


以上5条规则过于严格，事实上应该是这样：没有一个方法能够对对象的状态产生外部可见的改变，
然而，许多非可变类拥有一个或者多个非final的冗余域，它们把一些开销昂贵的计算结果缓存在这些域中。
如果将来再次请求这些计算，则直接返回这些被缓存的值，从而节约了重新计算所需要的开销。
这种技巧可以很好的工作，因为对象是非可变的，它的非可变性保证了这些计算如果被再次执行的话，会产生同样的结果。比如一些非可变类的hashCode可以使用这种方式。


总结：

除非有很好的理由要让一个类称为可变类，否则就应该是非可变的。
只有当确实认为达到满意的性能非常有必要时，才应该为非可变类提供公有的可变配套类。
如果一个类不能被做成非可变类，那么仍然应该尽可能的限制它的可变性。
构造函数应该创建完全初始化的对象，所有的约束关系应该在这时候建立起来，构造函数不应该把“只构造了一部分的实例”传递给其他的方法。
不应该在构造函数之外再提供一个公有的初始化方法，除非有绝对很好的理由要这么做。