                                                                                                                                      谨慎的使用重载
																   
Java对于重载方法(overloaded method)的选择是静态的，而对于被改写的方法(overridden method)的选择是动态的。
到底调用了哪个重载方法是在编译时刻作出决定的，对于被改写的方法，选择正确的版本是在运行时刻进行的，选择的依据是被调用方法所在对象的运行时类型。
如果一个实例方法在一个子类里被改写了，并且这个方法是在该子类的实例上被调用的，那么子类中被改写的方法将会执行，
而不管该子类实例的编译时类型到底是什么。具体示例见chapter6.item26.OverloadOverriddenDemo.java。

如果一个API的典型用户根本不知道"对于一组给定的参数，哪个重载方法将会被调用"，那么使用这样的API极有可能会导致错误。
这样的错误要等到运行时刻才会显现出来，许多程序员无法诊断出这样的错误。因此：

应该避免方法重载机制的混淆用法。

一个安全而保守的策略是：

永远不要导出两个具有相同参数数目的重载方法。(指导原则)

这项限制并不麻烦，因为总是可以给方法起不同的名字，而不使用重载机制。


对于构造函数，没有选择使用不同名字的机会，一个类的多个构造函数总是重载的。
在某些情况下，可以选择导出静态工厂，而不是构造函数，但这并不总是切合实际的。
因为有可能会导出多个具有相同参数数目的构造函数，所以有必要了解什么时候这样做是安全的。

如果对于任何一组给定的实际参数，哪一个重载方法将会应用于这一组参数是非常清楚的，则导出多个具有相同参数数目的重载方法是不可能引起混淆的。
比如对于某些重载方法，至少有一个对应的形参具有"根本不同"(指要把一种类型的实例转换为另一种类型显然是不可能的)的类型的情形。
这种情形下，哪个重载方法应用于一组给定的实际参数完全是由参数的运行时类型来决定的，不可能受到其编译时类型的影响，所以主要的混淆源头就消失了。

偶尔情况下，当更新一个已有的类以实现新的接口的时候，可能会被迫违反上面的指导原则。
但是只要当这两个重载方法在同样的参数上被调用时，它们执行相同的功能，则重载就不会带来危害。
程序员可能并不知道哪个重载函数会被调用，但只要这两个方法返回相同的结果就行。
确保这种行为的标准做法是：让更一般化的重载方法把调用转发给更特殊化的重载方法。

一般的，对于多个具有相同参数数目的方法来说，应该尽量避免重载方法。
在某些情况下，特别是涉及到构造函数的时候，遵循这条建议也许是不可能的。
在这种情况下，至少应该避免这样的情形：同一组参数只需经过类型转换就可以被传递给不同的重载方法。
