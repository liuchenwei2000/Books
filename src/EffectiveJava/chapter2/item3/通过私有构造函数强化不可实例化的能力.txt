                                                                                    通过私有构造函数强化不可实例化的能力


有些情况下可能会编出只包含静态方法和静态域的类，可以利用这种类，
把操作在原始类型的值或者数组类型上的相关方法组织起来；也可以把操作在实现特定接口的对象上的方法组织起来。

这样的工具类(utility class)不希望被实例化，对它进行实例化没有任何意义。
然而在缺少显式构造函数的情况下，编译器会自动提供一个公有的、无参数的默认构造函数。

企图通过将一个类做成抽象类来强制该类不可被实例化，这是行不通的。
该类可以被子类化，并且该子类也可以被实例化，并且这样会误导用户，以为这种类是专门为了继承而设计的。
只要让这个类包含个显式的私有构造函数，则它就不可被实例化了。示例见 UtilityDemo.java

这种做法也有副作用，它使得一个类不能被子类化。所有的构造函数都必须要调用一个可访问的超类构造函数，
无论显式的还是隐式地调用，在这种情形下，子类就没有可访问的构造函数来调用了。