                                                                       避免使用终结函数


终结函数(finalizer)，也就是Object中定义的finalize()方法，当垃圾回收器确定不存在对该对象的引用时，由垃圾回收器调用此方法。

终结函数通常是不可预测的，常常也是很危险的，一般情况下是不必要的。使用终结函数会导致不稳定的行为、更差的性能，以及带来移植性问题。
终结函数虽然也有其可用之处，但根据经验，应该避免使用。

在Java中，当一个对象变得不可到达的时候，垃圾回收器会回收与该对象相关联的存储空间，并不需要程序员做专门的工作。
如果要回收其他的非内存资源，一般用try-finally块来完成类似的工作。

终结函数并不能保证会被及时的执行，从一个对象变得不可到达开始，到它的终结函数被执行，这段时间长度是任意的、不确定的。
这意味着，时间关键的任务不应该由终结函数来完成。例如由终结函数来关闭一个已经被打开的文件，这是严重错误。

及时的执行终结函数正是垃圾回收算法的一个主要功能，这个算法在不同的JVM实现中会大相径庭。
如果一个程序依赖于终结函数被执行的时间点，那这个程序的行为在不同的JVM中运行的表现可能就会截然不同。

Java不仅不保证终结函数会被及时的执行，而且根本就不保证它们会被执行。
当一个程序终止的时候，其中某些已经无法访问的对象上的终结函数根本就没有被执行，这是完全有可能的。
所以，不应该依赖一个终结函数来更新关键性的永久状态。例如依赖于终结函数来释放一个共享资源(如数据库)上的永久锁。

如果有未被捕获的异常在终结过程中被抛出来，那么这种异常可以被忽略，并且该对象的终结过程也会被终止。
未被捕获的异常会使对象处于破坏的状态，如果另一个线程企图使用这样一个被破坏的对象，则任何不确定的行为都有可能发生。
正常情况下，一个未被捕获的异常将会使线程终止，并打印出栈轨迹，
但是如果一个异常发生在终结函数中，则情形不会这样——甚至连警告都不会打印出来。

如果一个类封装的资源(例如文件或者线程)确实需要回收，只需提供一个显式的终止方法，并要求该类的客户在每个实例不再有用的时候调用这个方法。
一个值得提及的细节是，该实例必须记录下自己是否已经被终止了，
显式的终止方法必须在一个私有域中记录下“该对象已经不再有效了”，其他的方法必须检查这个域，
如果在对象已经被终止之后，这些方法被调用的话，应该抛出异常。
显式终止方法的一个典型例子是InputStream/OutputStream上的close方法，还有Timer.cancel方法。
程序示例见chapter2.item6.ExplicitTerminationMethodDemo.java。


终结函数的合理用途

1，当一个对象的所有者忘记了调用显式终止方法的情况下，终结函数可以充当安全网。
虽然这样做并不能保证终结函数会被及时的调用，但迟一点释放关键资源总比永远不释放要好。

2，与对象的本地对等体(native peer)有关，本地对等体是一个本地对象(native object)。普通对象通过本地方法(native object)委托给一个本地对象。
因为本地对等体不是一个普通对象，所以垃圾回收器不会知道它，当它的普通对等体被回收的时候，它不会被回收。
如果本地对等体并不拥有关键资源的前提下，终结函数正是执行这些任务最合适的工具。
如果本地对等体拥有必须被及时终止的资源，那么该类应该具有一个显式的终止方法。
终止方法应该完成必要的工作以便释放关键的资源。终止方法可以是一个本地方法，或者它也可以调用本地方法。


注：

1，终结函数链并不会被自动执行，如果一个类(不是Object)由一个终结函数，并且一个子类改写了终结函数，
那么子类的终结函数必须要手工调用超类的终结函数。示例见chapter2.item6.FinalizerChainingDemo.java。

2，如果一个子类改写了超类的终结函数，但是忘了手工调用超类的终结函数(或者有意不调用)，那么超类的终结函数将永远也不会被调用到。
要防范这样的情况，只要为每一个将被终结的对象创建一个终结函数守卫者即可。示例见chapter2.item6.FinalizerGuardianDemo.java。


总结

除非是作为安全网，或者是为了终止非关键的本地资源，否则就不要使用终结函数。如果使用了，就要记住调用super.finalize。
最后如果要把一个终结函数与一个公有的非final类关联起来，那么考虑使用终结函数守卫者，以确保其终结函数会被执行。
