                                                  一般控制问题


要点

使布尔表达式简单可读，将非常有助于提高代码的质量。
深层次的嵌套使得子程序变得难以理解，所以要避免这么做。
结构化编程是一种简单并且仍然适用的思想：可以通过把顺序、选择和循环三者结合起来而开发出任何程序。
将复杂度降低到最低水平是编写高质量代码的关键。


详解


布尔表达式

在布尔表达式中应该用标识符true和false而不要用0和1等数值。

隐式地比较布尔值与true和false
把表达式当做布尔表达式，可以写出更清晰的判断语句。例如：
while(not done)...
while(a>b)
而不要写成
while(done == false)...
while((a>b) == true)...
通过使用隐式比较，能减少阅读你代码的人必须要记住的项数，这样写出的表达式读起来也更像英语中的对话。

简化复杂的表达式
1，拆分复杂的判断并引入新的布尔变量
与其写一个庞大的、具有很多项的复杂判断，还不如把中间结果赋给变量，以便于可以执行一个更简单的判断。
2，把复杂的表达式做成布尔函数
如果某项判断需要重复做，或者会搅乱对程序主要流程的理解，那么就可以把该判断的代码提取成一个函数，然后判断该函数的返回值。把某项判断放入一个布尔函数，就可以把它隔离起来，除非它非常重要，否则读者完全可以忘掉它。
新函数名为程序引入了一个抽象，可以清晰地在代码中说明该逻辑判断的目的。这样做比用注释好，因为人们更关心程序代码，可能不去读注释，而且这种描述更不容易过时。
3，用决策表代替复杂的条件
有时候有一个很复杂的判断，其中涉及到多个变量。这时用一个决策表代替if或者case语句来执行判断可能非常有帮助。如果你用的数据变了，那么只需要修改决策表即可，而无须修改代码；你只需要更新数据结构的内容就可以了。

编写肯定形式的布尔表达式
1，在if语句中，把判断条件从否定形式转换为肯定形式，并且互换if和else子句中的代码。
例如：
if(!statusOK){
// do something
}else {
// do something else
}
应写为肯定形式的布尔判断：
if(statusOK){
// do something else
}else {
// do something
}
也可以给变量换一个名字以表达判断真值的反义，写成：
if(statusError){
// do something
}else {
// do something else
}
2，用狄摩根定理简化否定的布尔判断
该定理揭示了一个表达式和另一个含义相同但却以双重否定形式表达的表达式之间的逻辑关系。比如：
not A and not B   等价于 not (A or B)
not A or not B   等价于 not (A and B)

用括号使布尔表达式更清晰
如果有一个复杂的布尔表达式，那么与其依赖于所用语言的求值顺序，不如用括号更清楚的表达你的意图。使用括号降低了对代码阅读者的要求，这些阅读者可能并不理解你的语言求布尔表达式值的微妙细节。

按照数轴的顺序编写数值表达式
应该很好的组织数值判断，使其顺序与数轴上的点排列顺序相符。如下：
MIN <= i and i <= MAX
i<MIN or MAX < i
这里的关键点在于要从左到右、从小到大的排列元素。


复合语句(语句块)

复合语句或语句块指的是一组语句，该组语句被视为一条单一的语句，用于控制程序流。可以通过在一组语句的外面扩上"{}"来创建复合语句。
1，把大括号对一起写出
先写块的开始和结束部分，然后再填充中间部分。
2，用大括号把条件表达清楚
在if判断后面只写一条语句可能看上去很美观，但是一经修改，这样的语句就会演变成复杂的块，而在这时用单一的语句就很容易引发错误。要用块来清楚的表达你的用意，无论块内的代码行数是1还是20。


过分深层的缩进，或者嵌套是产生混乱代码的罪魁祸首之一。
避免深层嵌套的方法：
1，通过重复检测条件中的某一部分来简化嵌套的if语句
如果嵌套层次变得太深，可以通过重复检测其中的一些条件来减少嵌套的层次。
比如：
if(boolean1)
{
  // do something
  if(boolean2){
    // do something
    if(boolean3){
      // do something
      if(boolean3){
        // do something
      }
    }
  }
}
通过重复检测减少嵌套层次：
if(boolean1)
{
  // do something
  if(boolean2){
    // do something 
  }
}
if(boolean1 && boolean1 && boolean3){
  // do something
    if(boolean3){
     // do something
  }
}
这个例子很实际，它表明你不能无偿的减少嵌套层次；作为减少嵌套层次的代价，你必须要容忍使用一个更复杂的判断。不过把嵌套层次从4层缩减到2层是很大的改进，所以值得考虑。
2，用break块来简化嵌套if
定义一段可以作为语句块来执行的代码。如果在语句块中的中间某些条件没有满足，那么就让执行直接跳到块的末尾。这种技巧很不常见。
3，把嵌套if转换成一组if-then-else语句
比如：
if(10 < quantity)
{
  if(100 < quantity){
    if(1000 < quantity){
      discount = 0.1;
    }else {
    discount = 0.05;
    }
  }else {
  discount = 0.025;
  }
}else {
  discount = 0;
}
转换成使用一组if-then-else：
if(1000 < quantity){
  discount = 0.1;
}else if(100 < quantity && quantity <= 1000){
  discount = 0.05;
}else if(10 < quantity && quantity <= 100){
  discount = 0.025;
}else if(quantity <= 10){
  discount = 0;
}
4，把嵌套if转换成case语句
可以用case语句重写一些判断，特别是那些含有整数的判断，而不是去用一长串if和else。
5，把深层嵌套的代码抽取出来放进单独的子程序
如果深层嵌套出现在循环里，通常都可以通过把循环体提取成子程序来加以改善。当嵌套是由于条件和迭代二者共同产生的时候，这么做将特别有效。把if-then-else分支保留在主循环中，以便显示决策的分支，然后把分支中的语句提取成单独的子程序。
6，使用面向对象的方法
对于各种系统，都可以用工厂方法模式来替换其中的switch语句。


程序复杂度
程序复杂度一个衡量标准是，为了理解应用程序，必须在同一时间记住的智力实体的数量。
衡量复杂度的方法：计算子程序中决策点的数量，方法如下所述：
1，从1开始，一直往下通过程序。
2，一旦遇到以下关键字，或者其同类的词，就加1：
if、while、repeat、for、and、or
3，给case语句中的每一种情况都加1。
计算出决策点的数量以后，就可以用得到的数值分析子程序的复杂度了：
0-5：子程序可能还不错
6-10：得想办法简化子程序了
10+：把子程序的某一部分拆分成另一个子程序并调用它
把子程序的一部分提取成另一个子程序，不会降低整个程序的复杂度，只是把决策点移到其他地方。但是这样做可以降低你在同一时间必须关注的复杂度水平。由于重点是要降低你需要在头脑中同时考虑的项目的数量，所以降低一个给定子程序的复杂度是有价值的。
