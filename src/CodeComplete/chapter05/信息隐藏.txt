                                                信息隐藏


信息隐藏是结构化程序设计与面向对象设计的基础之一(黑盒子的概念就是来源于此)。在面向对象设计中，又引出了封装和模块化的概念，并与抽象的概念紧密相关。信息隐藏强调的是隐藏复杂度。

当信息被隐藏后，每个类(包或者子程序)都代表了某种对其他类保密的设计或构建决策。隐藏起来的秘密可能是某个异变的区域，或者某种文件格式，某种数据类型的实现方式，或某个需要隔离的区域，在这个区域中发生的错误不会给程序其余部分带来太大的损失。在这里，类的职责就是把这部分信息隐藏起来，并保护自己的隐私权。对系统的非重大改动可能会影响到某个类中的几个子程序，但不应该波及到类接口的外面。在设计一个累的时候，要确定类的哪些特性应该对外可见，哪些应该隐藏起来。一个类在内部可能用到了多种数据类型，却不对外暴露有关它们的任何信息。类的接口应该尽可能少的暴露其内部工作机制。隐藏设计决策对于减少改动所影响的代码量是至关重要的，详见chapter5.IDDemo。

信息隐藏中的没秘密主要分为两大类：
1，隐藏复杂度，这样你就不用再去应付它，除非你要特别关注的时候。
2，隐藏变化源，这样当变化发生时，其影响就能被限制在局部范围内。复杂度的根源包括复杂的数据类型、文件结构、布尔判断以及晦涩的算法等等。


信息过度分散是信息隐藏的障碍

比如将100这个数字直接写到程序里，这样会导致对它的引用过于分散，最好将这部分信息隐藏起来，比如写入一个叫MAX_NUMBER的常量中，而对这个常量的值进行改动只需要在一处即可。
比如一个在程序全局范围内都可以访问的含有100个元素的数组，如果程序直接使用这个数据，那么该数据项的实现细节——比如它是一个数组，最多可以放100个元素——都会在程序中到处分散。而如果程序仅是通过访问器子程序来使用该数据的话，就只有访问器子程序才知道其实现细节了。

问题“这个类需要隐藏些什么？”正切中了接口设计中的核心。如果你能在给类的公开接口中增加函数或者数据而不牺牲该类的隐秘性，那么就去做，否则就不要做。在设计的所有层面上(类、子程序、变量等)，都可以通过询问该隐藏些什么来促成好的设计决策。

找出容易改变的区域

好的程序设计所面临的最重要挑战之一就是适应变化。目标应该是把不稳定的区域隔离出来，从而把变化所带来的影响限制在一个子程序、类或者包的内部。下面是应对各种变动应该采取的措施：
1，找出看起来容易变化的项目
在需求层次上找出看起来容易变化的地方，比如下面这些在所有项目中都容易发生变化的区域：
a，业务规则
如果你遵循信息隐藏的原则，那么基于这些业务规则的逻辑就不应该遍布于整个程序，而是仅仅隐藏于系统的某个角落。
b，对硬件的依赖性
把对硬件的依赖隔离在它们自身的子系统或类中。这种隔离会非常有利于你把子程序移植到新的硬件环境下。并且当你为可能变化的硬件开发程序时，可以写软件来模拟与特定硬件的交互。
c，输入和输出
如果你的程序创建了自己的数据文件，那么该文件格式就可能会随软件开发的不断深化而变化。用户层的输入和输出格式也会改变——输出页面上字段的位置、数量和排列顺序都可能会变。
d，困难的设计区域和构建区域
把困难的设计区域和构建区域隐藏起来也是很好的想法，因为这些代码可能因为设计得很差而需要重新做。请把它们隔离起来，把其拙劣的设计和构建对系统其余部分的可能影响降到最低。
e，状态变量
状态变量用于表示程序的状态，与大多数其他的数据相比，这种东西更容易改变。可以在使用状态变量时增加至少两层的灵活性和可读性：
e.1，不要使用布尔变量作为状态变量，请换用枚举类型。
给状态变量增加一个新的状态是很常见的。
e.2，使用子程序取代对状态变量的直接检查。
通过检查子程序而不是检查状态变量，使程序能够去测试更复杂的状态情况。

2，把容易变化的项目分离出来
把第一步中找出的容易变化的组件单独划分成类，或者和其他容易同时发生变化的组件划分到同一个类中。
3，把看起来容易变化的项目隔离开来
设法设计好类之间的接口，使其对潜在的变化不敏感。设计好类的接口，把变化限制在类的内部，且不会影响类的外部。任何使用了这个将会发生变化的类的其他类都不会察觉到变化的存在，类的接口应该肩负起保护类的隐私的职责。

找出容易发生变化的区域的一个好办法是：
首先找出程序中可能对用户有用的最小子集。这一子集构成了系统的核心，不容易发生改变。接下来用最小的步伐扩充这个系统。当你考虑功能上的改变时，同时要考虑质的变化，这些潜在的改进区域就构成了系统中的潜在变化。通过首先定义清楚核心，就可以认清哪些组件属于附加功能，这时就可以把它们提取出来，并把它们的可能改进隐藏起来。
