                                         简 化 函 数 调 用
1，Rename Method(重新命名函数)
让函数的名称能够解释函数的用途。如果函数是public的，为了安全，可以新建一个好名字函数，然后把旧函数声明为"Deprecated"。
如果该函数被子类化，则需要同时修改子类的函数。
2，Add Parameter(添加参数)
某个函数需要从调用段得到更多的信息，为这个函数添加所需要的信息参数(包括对象)。
重构的时候注意被子类实现的函数的修改和public函数的修改。
3，Remove Parameter(移除参数)
当函数本体不再需要某个参数的时候将这个参数去除。重构过程和上面的相似。
4，Separate Query from Modifier(将查询函数和修改函数分离)
若某个函数既返回对象状态值又修改对象状态，建立两个不同的函数，一个只负责查询，一个只负责修改。
(一个规则：任何有返回值的函数都不应该有看得到的副作用)
作法：
新建一个查询函数，令它返回的值与原函数相同。
修改原函数，令他调用查询函数，并返回获得的结果，原函数中的每个return语句都应该像这样：return newQuery()。
将原函数的每一个被调用点替换为对查询函数的调用，然后在调用查询函数的那一行之前加上对原函数的调用，
并将原函数的返回值改为void，并删掉其中所有的return语句。
5，Parameterize Method(令函数携带参数)
若干函数做了类似的工作，但是在函数本体重却包含了不同的值，建立单一函数，以参数表达那些不同的值。
6，Replace Parameter with Explicit Methods(以明确函数取代参数)
某一个函数其内行为完全取决于参数值，那就针对该参数的每一个可能值，建立一个独立的函数。
然后在原函数的每一个被调用点改为调用上述的某个合适的新函数。最后删除原(带有条件判断的)函数。
7，Preserve Whole Object(保持对象完整)
从某个对象中取出若干值，将它们作为某一次函数调用时的参数，可改为使用传递整个对象的方式。
8，Replace Parameter with Methods(以函数取代参数)
对象调用某个函数并将所得结果作为参数传递给另一个函数，而接受该参数的函数也可以(也有能力)在函数体中调用前一个函数，
那就让参数接受者去除该项参数，并在函数体中直接调用前一个函数获得所需要的数据。
如果函数可以通过其他途径(而非参数列)获得参数值，那就不应该通过参数获得该值。
9，Introduce Parameter Object(引入参数对象)
若某些参数总是很自然的同时出现，那就以一个对象取代这些参数。
10，Remove Setting Method(移除设值函数)
若类中的某个值域，应该在对象初创时被设值然后就不再改变，那就去掉该值域的所有设值函数，同时将该值域设为final。
11，Hide Method(隐藏某个函数)
若某个函数从来没有被任何类用到，那就将这个函数修改为private，尽可能降低所有函数的可见度。
12，Replace Constructor with Factory Method(以工厂函数取代构造函数)
若在创建对象的时候不仅仅是对它做简单的构建动作(比如需要根据型别码创建相应的对象)那就将构造函数替换为工厂函数。
当把型别码替换为子类的时候使用工厂方法可以将子类对用户隐藏起来。
作法：
新建一个工厂方法，然它调用现有的构造函数，将对构造函数的调用替换为对工厂方法的调用，
每次替换后，编译并测试，然后将构造函数声明为private。
13，Encapsulate Downcast(封装向下转型动作)
某个函数返回的对象，需要由函数调用者执行向下转型动作，将向下转型动作转移到函数中。
这样可以向用户封装内部信息，不用把这种向下转型推给用户去做。
作法：
找出必需对函数调用结果进行向下转型的地方，这种情况通常出现在返回一个群集或迭代器的函数中，将向下转型动作搬移到该函数中。
原函数：
public Object getFirstPerson(){
    return list.getFirst();
}
修改后的函数：
public Person getFirstPerson(){
    return (Person)list.getFirst();
}
14，Replace Error Code with Exception(以异常取代错误码)
若某个函数返回一个特定的标志码用以表示某种错误情况，改用异常。
15，Replace Exception with Test(以测试取代异常)
当面对一个调用者可预先加以检查的条件，若抛出了一个异常，则修改调用者，使它在调用函数之前先做检查。
异常只应该被用于异常的罕见的行为，也就是那些产生意料之外的错误的行为，而不应该成为条件检查的替代品。