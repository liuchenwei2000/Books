                                     函 数 的 重 构 手 法
1，Extract Method(提炼方法)
某些代码可以被组织在一起并独立出来，比如一个过长的函数或者一段需要注释才能让人理解用途的代码，
则将这段代码放到一个独立的函数中，并让函数名称解释该函数的用途。
以它“做什么”去命名它而不是以它“怎样做”命名。
2，Inline Method(将函数内联化)
某些方法其方法体与其方法名一样清楚易懂，则在方法调用点插入方法体，然后删除该方法。
作法：
先检查方法，确定它不具多态性，然后找出这个方法的所有被调用点，将这个方法的所有被调用点都替换为方法体，
通过测试之火删除该方法的定义。如果Inline之后出现了其他的一些更麻烦的情况，那就不如不用这个重构手法。
3，Inline Temp(将临时变量内联化)
若一个临时变量只被一个简单表达式赋值一次，但是它妨碍了其他重构手法(比如提炼方法)则将所有对改变量的引用动作，
替换为对它赋值的那个表达式本身。
作法：
如果这个临时变量没有被声明为final，那就将它声明为final，然后编译，这可以检查临时变量是否是真的只被赋值一次。
找到该临时变量的引用点，将它们替换为实际的表达式，然后编译测试，通过之后删除临时变量的声明和赋值语句。
4，Replace Temp with Query(以查询取代临时变量)
若一个临时变量保存某一表达式的运算结果，则将这个表达式提炼到一个独立方法中(查询式方法)，
将这个临时变量的所有被引用点替换为对新函数的调用，新函数还可被其他函数使用。
该手法往往是Extract Method之前必不可少的一个步骤，因为局部变量会使代码难以被提炼。
作法：
找出只被赋值一次的临时变量(如超过一次则把它分解成几个变量)，将该变量声明为final，
编译之后将对其赋值的表达式提炼到一个独立的函数中，该函数首先声明为private，
日后需要的话可以放松对它的保护，确保提炼出的函数没有任何副作用，编译测试之后对临时变量实施Inline Temp。
5，Introduce Explaining Variable(引入解释性变量)
讲一个复杂的表达式(或其中一部分)的结果放进一个临时变量，以此变量名称来解释表达式用途。
在条件逻辑和较长算法时，这样做可以提高代码的可读性。但是某些时候，用Extract Method会更好一些。
当提炼方法需要花费很多工作量的时候，或者某算法有很多局部变量，那么就应用这种重构手法。
6，Split Temporary Variable(剖析临时变量)
如果某个临时变量既不是循环变量(如for循环中的i)也不是集用临时变量(这些变量的作用有累加、字符串接合、写入流、像集合中添加元素等等)
而被赋值超过一次，则针对每次赋值，创造一个独立的对应的临时变量。每个临时变量只承担一个责任，这样易于阅读。
7，Remove Assignments to Parameters(移除对参数的赋值动作)
若对一个参数赋值则要以一个临时变量取代该参数的位置(尽量不要对参数赋值，这可以通过在参数前加final来进行检验)。
8，Replace Method with Method Object(以函数对象取代函数)
若有一个大型函数，其中对局部变量的使用使你无法采用Extract Method，可将这个函数放入到一个单独对象中，
把局部变量变为对象内的值域，然后在同一个对象中将这个大型函数分解成为数个小型函数。
作法：
建立一个新的class，根据待被处理函数的用途为这个class命名
在新class中建立一个final值域用来保存原函数中的对象，同时原函数中每个临时变量和每个参数在新class中都应该有一个相应的值域保存。
在新class中建立一个构造函数，接受源对象及原函数的所有参数作为参数，然后建立一个compute()函数，
将原函数的代码拷贝到compute()函数中，如果需要调用源对象的任何函数，则用为它建立的值域来调用，编译之后，
将原函数的函数本体替换为这样的语句：新建一个class的对象，调用compute()函数。
由于所有的局部变量都变成了值域，这样就可以任一分解这个compute()函数而不必传递任何参数。                       
