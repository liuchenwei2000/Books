以固定而全局性的顺序取得多个locks以避免死锁


当两个或多个线程因互相等待而阻塞时，就发生了死锁。
举例说明：
线程A等待取得线程B持有的资源b，因而被线程B阻塞；线程B则必须在取得线程A持有资源a之后才释放它持有的资源b。
这样一来，两个线程相互等待对方释放自己需要的资源，僵持不下，发生了死锁。

死锁示例见DeadLockDemo.java。避免死锁的做法有两种：

1.令代码以固定且全局性的顺序取得locks。

在DeadLockDemo.java中，如果两个线程都是以相同的参数顺序调用sumArrays2方法，死锁就不会发生。
这便是要求多线程程序员，在调用那些“于函数本体内将对象参数锁定”的函数时要格外小心。

2.将锁定顺序嵌入对象内部。

这就允许代码征询即将取其lock的那个对象，确定锁定顺序。只要被锁定的对象都支持锁定顺序，而且抓取lock的代码都坚守这个策略，就可避免死锁。
这个方法的缺点在于，必须付出额外的内存和运行期代价。示例见LockOrder.java。