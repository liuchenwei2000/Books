别只依赖finalize()清理内存以外的资源


在垃圾回收器回收某个class对象之前，JVM会调用这个class的finalize()。这个函数被宣扬为“在回收某个对象的内存之前确保释放非内存资源”的有效方法。
由于垃圾回收器仅仅释放对象内存，finalize()因此提供了一种释放其他资源的方法。

问题的症结在于，对象的finalize()函数只有在垃圾回收器释放对象占用的空间之前才会被调用。
当垃圾回收器执行时，可能并非所有符合回收条件的对象都被回收（具体取决于垃圾回收机制所采用之算法），此外也无法保证finalize()在可预期的时间上执行。
这是由于“终结(finalization)动作”与“垃圾回收”之间的异步本性造成的。由此推断，finalize()未必在程序结束前被执行。
这意味着即使正确编写了finalize()来释放非内存资源，程序结束前仍然有可能耗尽这些资源。

避免此问题的可能方法之一是使用System.runFinalization()函数，它要求JVM在垃圾回收器下次运行之前，对所有标记为可终结的对象调用其finalize()。
是否能够做到这一点，取决于垃圾回收器和这个函数所采用的算法，但不能保证调用该函数就一定会执行finalize()。

综上所言，不能把希望单单寄托于finalize()被调用这件事情上。应当实现自己的非内存资源清理机制，然后结合class的finalize()一起使用。方法如下：

1.必须确保那些需要清理的classes都必然包含一个public函数，专门负责释放非内存资源。
2.这个函数应当被class的finalize()调用，以确保当JVM调用finalize()时能够释放非内存资源。
3.如果finalize()未被调用，用户则可以直接调用这个public函数以释放非内存资源。