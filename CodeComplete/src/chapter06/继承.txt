                                           有关设计和实现的问题


包含(has-a)表示一个类含有一个基本数据元素或对象，继承比包含需要更多的技巧，包含才是面向对象编程中的主力技术。

继承(is-a)是指一个类是另一个类的一种特化(specialization)。继承的目的在于通过“定义能为两个或更多个派生类提供共有元素的基类”的方式写出更精简的代码。其中的共有元素可以使子程序接口、内部实现、数据成员或数据类型等。继承能把这些共有的元素集中在一个基类中，从而有助于避免在多处出现重复的代码和数据。

当决定使用继承时，必须要做如下几项决策：
1，对于每一个成员函数而言，它应该对派生类可见(protected)吗？它应该有默认的实现吗(abstract)？这一，默认的实现能被覆盖(override)吗(final)？
2，对于每一个数据成员而言(变量、常量、枚举)，它应该对派生类可见(protected)吗？

如何考虑这些事项：
1，用public继承来实现“是一个”的关系
基类既对派生类将会做什么设定了预期，也对派生类能怎么运作提出了限制。如果派生类不准备完全遵守由基类定义的同一个接口契约，继承就不是正确的实现技术了。要么换用包含的方式，或者对继承体系的上层做修改。
2，如果某个类并未设计成可被继承的，就应该把它定义成final
3，遵循里氏替换原则
除非派生类真的是一个更特殊的基类，否则不应该从基类继承。派生类必须能通过基类的接口而被使用，且使用者无需了解两者之间的差异。对于基类中定义的所有子程序，用在它的任何一个派生类中时的含义都应该是相同的。
如果程序遵循里氏替换原则，继承就能成为降低复杂度的一个强大工具，因为它能让程序员关注于对象的一般特性而不必担心细节。如果程序员必须要不断地思考不同派生类的实现在语义上的差异，继承就只会增加复杂度了。
4，确保只继承需要继承的部分
派生类可以继承成员函数的接口和/或实现。因为要继承接口所以才继承实现，或仅仅是因为要继承实现所以才继承接口，这两类情况都值得注意。如果你只是想使用一个类的实现而不是接口，那就应该采用包含方式，而不是继承。
5，派生类中的成员函数不要与基类中不可覆盖的成员函数重名
如果一个成员函数在基类中是private的话，其派生类可以创建一个同名的成员函数。这个函数是令人困惑的，难于阅读的，看上去似乎是多态的，但事实上却并非如此，只是同名而已。
6，把共用的接口、数据及操作放到继承树中尽可能高的位置
这样派生类使用它们的时候就很容易。可以根据抽象性来决定高度的位置，如果发现一个子程序移到更高的层次会破坏该层对象的抽象性，就可以停止了。
7，只有一个派生类的基类是值得怀疑的
这是在进行提前设计，不要创建任何并非绝对必要的继承结构。
8，派生后覆盖了某个子程序，但在其中没做任何操作，这种情况也值得怀疑
这通常表明基类的设计中有错误。
9，尽量使用多态，避免大量的类型检查
频繁重复出现的case语句有时是在暗示，采用继承可能是更好的设计选择——尽管并不总是如此。
10，让所有数据都是private(而不是protected)
当从一个类继承时，就拥有了能够访问该类中的protected子程序和protected数据的特权。如果派生类真的需要访问基类的属性，就应提供protected访问器函数(getter/setter)。

何时可以使用继承，何时又该使用包含：
1，如果多个类共享数据而非行为，应该创建这些类可以包含的共用对象。
2，如果多个类共享行为而非数据，应该让它们从共同的基类继承而来，并在基类里定义共用的子程序。
3，如果多个类既共享数据也共享行为，应该让它们从一个共同的基类继承而来，并在基类里定义共用的数据和子程序。
4，当你想由基类控制接口时，使用继承；当你想自己控制接口时，使用包含。
