                                                        良好的封装


抽象通过提供一个可以让你忽略实现细节的模型来管理复杂度，而封装则强制阻止你看到细节——即便你想这么做。要么就是封装与抽象两者皆有，也么就是两者皆失。
1，尽可能的限制类和程序员的可访问性
更重要的建议是：采用哪种方式能最好的保护接口对象的完整性。如果暴露一个子程序不会让抽象变得不一致的话，这么做就很可能是可行的。如果不确定，那么多隐藏通常比少隐藏要好。
2，不要公开暴露成员数据
暴露成员数据会破坏封装性，从而限制你对这个抽象的控制能力。
比如一个类暴露了一个成员：double x; 这就破坏了封装性，因为调用方代码可以自由地使用这个类中的x数据，而这个类却连这个数据什么时候被改动过都不知道。如果这个类仅仅暴露了这个成员数据的访问方法getter/setter的话，那它还是封装完好的。因为使用者无法得知底层实现用的是不是double x。
3，避免把私用的实现细节放入类的接口中
做到真正的封装以后，程序员们是根本看不到任何实现细节的，无论是从字面上还是含义上。
4，不要对类的使用者做出任何假设
类的设计和实现应该符合在类的接口中所隐含的契约。它不应该对接口会被如何使用或不会被如何使用做出任何假设——除非在接口中有过明确说明。
5，不要因为一个子程序里仅使用公用子程序就把它归入公开接口
要考虑的是，把这个子程序暴露给外界后，接口所展示的抽象是否还是一致的。
6，让阅读代码比编写代码更方便
在创建类的接口时，即使某个子程序与接口的抽象不很相配，有时人们也往往把这个子程序加到接口中，从而让这个类的某处调用代码能更方便的使用它。
7，要格外警惕从语义上破坏封装性
从语法的角度说，要想避免窥探另一个类的内部实现细节，只要把它内部的子程序和数据都声明为private就可以了。下面的例子是从语义上破坏封装性：
a，不去调用A类的init()子程序，因为你知道A类的firstOperation()子程序会自动调用它。
b，使用ClassB.MAX_VALUE而不用ClassA.MAX_VALUE，因为你知道它们两个的值是相等的。
问题在于，它们让调用方代码不是依赖于类的公开接口，而是依赖于类的实现。每当你发现自己是通过查看类的内部实现来得知该如何使用这个类的时候，你就不是在针对接口编程了，而是在透过接口针对内部实现编程了。如果透过接口来编程的话，封装性就被破坏了。
8，留意过于紧密的耦合关系
耦合是指两个类之间关联的紧密程序，这种关联越松越好。建议如下：
a，尽可能的限制类和成员的可访问性。
b，在基类中把数据声明为private而不是protected，以降低派生类和基类之间耦合的程序。
c，避免在类的公开接口中暴露成员数据。
d，要对从语义上破坏封装性保持警惕。
耦合性与封装性有着非常密切的联系。紧密的耦合性总是发生在抽象不严谨或封装性遭到破坏的时候。如果一个类提供了一套不完整的服务，其他的子程序就能要去直接读写该类的内部数据。这样一来就把类给拆开了，把它从一个黑盒子变成了一个玻璃盒子，从而事实上消除了类的封装性。
