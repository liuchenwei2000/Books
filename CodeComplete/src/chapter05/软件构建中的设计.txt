                                                  软件构建中的设计


要点

软件的首要技术使命就是管理复杂度。以简单性作为努力目标的设计方案对此最有帮助。
简单性可以通过两种方式来获取：一是减少在同一时间所关注的本质性复杂度的量，二是避免生成不必要的偶然的复杂度。
设计是一种启发式的过程。固执于某一种单一方法会损害创新能力，从而损害你的程序。
好的设计都是迭代的。你尝试设计的可能性越多，最终设计方案就会变得越好。
信息隐藏是个非常有价值的概念，通过询问我应该隐藏些什么能够解决很多困难的设计问题。


详解


软件设计意味着去构思、创造或发明一套方案，把一份计算机软件的规格说明书要求转变为可实际运行的软件。设计就是把需求分析和编码调试连在一起的活动。好的高层次设计能提供一个可以稳妥容纳多个较低层次设计的结构。

设计是一个险恶的问题

险恶的(wicked)问题就是那种只有通过解决或者部分解决才能被明确的问题。你必须首先把这个问题解决以便以便明确的定义它，然后再次解决该问题，从而形成一个可行的方案。

软件设计的成果应该是组织良好、干净利落的，然而形成这个设计的过程却并非如此清爽。说设计了无章法，是因为在此过程中你会采取很多错误的步骤，多次误入歧途——你会犯很多的错误。事实上，犯错正是设计的关键所在——在设计阶段犯错并加以改正，其代价要比在编码后才发现同样的错误并彻底修改低得多。
设计就是确定取舍和调整顺序的过程，要去衡量彼此冲突的各项设计特性，并尽力在其中寻求平衡。
设计受到诸多的限制，比如时间、空间和资源。
设计是不确定的，对于同一个程序每个人都会有不同的设计。
设计是一个启发式过程，设计过程总会试验和犯错误，没有任何工具是用之四海而皆灵的。
设计是自然而然形成的，在不断地设计评估、非正式讨论、写试验代码以及修改试验代码中演化和完善的。


软件的首要技术使命：管理复杂度

作为软件开发人员，不应该试着在同一时间把整个程序都塞进自己的大脑，而应该试着以某种方式去组织程序，以便能够在一个时刻可以专注于一个特定的部分。这么做的目的是尽量减少在任一时间所要考虑的程序量。在软件架构的层次上，可以通过把整个系统分解为多个子系统来降低问题的复杂度。子系统间的相互依赖越少，就越容易在同一时间里专注问题的一小部分。精心设计的对象关系使关注点相互分离，从而使你能在每个时刻只专注于一件事情。保持子程序的短小精悍也能帮助你减少思考的负担。从问题的领域着手，而不是从底层实现细节入手去编写程序，在最抽象的的层次上工作，也能减少人的脑力负担。


理想的设计特征

这些目标之间有时会相互抵触，但这正是设计中的挑战所在——在一系列相互竞争的目标之中做出一套最好的折中方案。

1，最小的复杂度
要避免做出“聪明的”的设计，因为这种“聪明的”设计常常都是难以理解的。应该做出简单且易于理解的设计。如果你的设计方案不能让你在专注于程序的一部分时安心的忽视其他部分的话，这一设计就没有什么作用了。
2，易于维护
意味着在设计时为做维护工作的程序员着想。
3，松散耦合
意味着在设计时让程序的各个组成部分之间关联最小。通过应用类接口中的合理抽象、封装性及信息隐藏等原则，设计出相互关联尽可能最少的类。
4，可扩展性
能增强系统的功能而无需破坏其底层结构。可以改动系统的某一部分而不会影响到其他部分。越是可能发生的改动，越不会给系统造成什么破坏。
5，可重用性
意味着所设计的系统的组成部分能在其他系统中重复使用。
6，高扇入
让大量的类使用某个给定的类。这意味着设计出的系统很好的利用了在较低层次上的工具类。
7，底扇出
让一个类里少量或适中的使用其他的类。高扇入(超过7个)说明一个类使用了大量其他的类，因此可能变得过于复杂。研究发现，无论考虑某个子程序调用其他子程序的量，还是考虑某个类使用其他类，低扇出的原则都是有益的。
8，可移植性
系统能很方便的移植到其他环境中。
9，精简性
意味着设计出的系统没有多余的部分，因为任何多余的代码也需要开发、复审和测试，并且当修改了其他代码之后还要重新考虑它们。软件的后续版本也要和这些多余代码保持向后兼容。
10，层次性
意味着尽量保持系统各个分解层的层次性，使你能在任意的层面上观察系统，并得到某种具有一致性的看法。
11，标准技术
一个系统所依赖的外来的、古怪的东西越多，别人在第一次想要理解它的时候就越是头疼。要尽量用标准化的、常用的方法，让整个系统给人一种熟悉的感觉。


设计的层次

一个程序中的设计层次：系统首先被组织成子系统，子系统被进一步分解成类，然后类又被分解为子程序和数据，每个子程序的内部也需要进行设计。
1，软件系统
往往先从子系统或者包这些类的更高组织层次来思考会更有益处。
2，分解为子系统或包
在这一层次上设计的主要成果是识别出所有的主要子系统。确定如何把程序分为主要的子系统，并定义清楚允许各子系统如何使用其他子系统。有一点很重要，即不同子系统之间相互通信的规则。如果所有的子系统都能同其他子系统通信，你就完全失去了把它们分开所带来的好处，应该通过限制子系统之间的通信来让每个子系统更有存在意义。有一条很好的基本原则，系统层设计图应该是无环图。
常用的子系统：业务规则、用户界面、数据库访问、对系统的依赖性。
3，分解为类
在这一层次上的设计包括识别出系统中所有的类。当定义子系统中的类时，也就同时定义了这些类与系统的其余部分打交道的细节，尤其是要确定好类的接口。
4，分解成子程序
包括把每个类细分为子程序，在第3层中定义出的类接口已经定义了其中一些子程序，这一层的设计将细化出类的私有(private)子程序。


启发式方法进行设计

1，找出现实世界中的对象
辨识现实世界中的对象以及人造的对象。使用对象进行设计的步骤是：
辨识对象及其属性(数据和方法)。
确定可以对各个对象进行的操作。
确定各个对象能对其他对象进行的操作。
确定对象的哪些部分对其他对象可见(public)，哪些部分是私有的(private)。
定义每个对象的公开接口。
这些步骤并无须以特定顺序来完成，它们也经常会被反复执行。
2，形成一致的抽象
抽象是一种能让你在关注某一概念的同时可以放心的忽略其中一些细节的能力——在不同的层次处理不同的细节。基类也是一种抽象，它使你能集中精力关注一组派生类所具有的共同特性，并在基类的层次上忽略各个具体派生类的细节。一个好的接口也是一种抽象，它能让你关注于接口本身而不是类的内部工作方式。
3，封装实现细节
封装填补了抽象留下的空白。抽象是说：可以让你从高层的细节来看到一个对象。而封装则说：除此之外，你不能看到对象的任何其他细节层次。封装不只是让你能用简化的视图来看复杂的概念，同时还不能让你看到复杂概念的任何细节。
4，当继承能简化设计时就继承
定义对象之间的相同点和不同点就叫继承。继承的好处在于它能很好的辅佐抽象的概念，能简化编程的工作。


其他值得推荐的启发式方法
1，高内聚性
内聚性指的是类内部的子程序或者子程序内的所有代码在支持一个中心目标上的紧密程度——这个类的目标是否集中。包含一组密切相关的功能的类被称为有着高内聚性，而这种启发式方法的目标就是使内聚性尽可能的高。内聚性是用来管理复杂度的有用工具，因为一个类的代码越集中在一个中心目标的时候，你越容易记住这些代码的功能所在。
2，构造分层结构
分层结构指的是一种分层的信息结构，其中最通用的或者最抽象的概念表示位于层次关系的最上面，而越来越详细的具有特定意义的概念表示放在更低的层次中。在软件中，在类的层次结构中可以看到分层的组织结构，子程序调用也具有分层结构。
3，为测试而设计
如果为了便于测试而设计这个系统，需要设法组织好每一个子系统，使它与其他子系统之间的依赖关系最小。为测试而设计很容易产生更为规整的类接口，而这通常是非常有益处的。
