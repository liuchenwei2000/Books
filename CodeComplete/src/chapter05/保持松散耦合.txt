                                保持松散耦合(keep coupling loose)


耦合度表示类与类之间或者子程序与子程序之间关系的紧密程度。耦合度设计的目标是创建出小的、直接的、清晰的类或子程序，使它们与其他类或子程序之间关系尽可能的灵活，这就被称作松散耦合。

模块(类和子程序)之间的耦合关系会松散到恰好能使一个模块能够很容易地被其他模块使用。在软件中，要确保模块之间的连接关系尽可能的简单。尽量使你创建的模块不依赖或者很少依赖其他模块。

衡量模块之间耦合度时可采用的标准：
1，规模
指的是模块之间的连接数。对于耦合度来说，小就是美，因为只要做很少的事情，就可以把其他模块与一个有着很小的接口的模块连接起来。意味着子程序的参数数量要尽可能少，类的公开接口方法要尽可能少。
2，可见性
指的是两个模块之间的连接的显著程度。通过参数表传递数据便是一种明显的连接，因此值得提倡。通过修改全局数据而使另一个模块能够使用该数据则是一种鬼鬼祟祟的做法，是很不好的设计。
3，灵活性
指的是模块之间的连接是否容易改动。一个模块越容易被其他模块所调用，那么它们之间的耦合关系就会越松散。这种设计非常不错，因为它更灵活，并且易于维护。因此，在创建系统架构时，要按照尽可能缩减相互连接的准则来分解程序。

耦合的种类：
1，简单数据参数耦合
当两个模块之间通过参数来传递数据，并且所有的数据都是简单数据类型，它们的耦合关系就是简单数据参数耦合。这种耦合关系是正常的，可以接受的。
2，简单对象耦合
如果一个模块实例化一个对象(组合)，那么它们之间的耦合关系就是简单对象耦合的。这种耦合关系也很不错。
3，对象参数耦合
如果Object1要求Object2传给它一个Object3，那么这两个模块就是对象参数耦合的。与1相比，这种耦合关系更紧密一下，因为它要求Object2了解Object3。
4，语义上的耦合
最难缠的耦合关系是这样发生的：一个模块不仅使用了另一个模块的语法元素，而且还使用了有关那个模块内部工作细节的语义知识。比如：
a，module1向module2传递了一个控制标志，用它告诉module2该做什么。
这种方法要求module1对module2的内部工作细节有所了解，也就是说需要了解module2对控制标志的使用。
b，module2在module1修改了某个全局数据之后使用该全局数据。
这种方式就要求module2假设module1对该数据所做出的修改符合module2的需要，并且module1已经在恰当的时间被调用过。
c，module1的接口要求它的module1.init()子程序必须在它的module1.routine()之前得到调用。module2知道module1.routine()无论如何都会调用module1.init()，所以它在实例化module1之后只是调用了module1.routine()，而没有先去调用module1.init()。
d，module1把Object传给module2。
由于module1知道module2只用了Object的七个方法中的3个，因此它只部分初始化Object——只包含了那三个方法所需的数据。
e，module1把BaseObject传给了module2。
由于module2知道module1实际上传给它的是DerivedObject，所以它把BaseObject传换成DerivedObject，并且调用了DerivedObject特有的方法。

语义上的耦合是非常危险的，因为更改被调用的模块中的代码可能会破坏调用它的模块，破坏的方式是编译器无法检查的，也会使调试工作变得很困难。

松散耦合的关键之处在于，一个有效的模块提供出了一层附加的抽象——一旦你写好了它，就可以想当然的去用它。这样就降低了整体系统的复杂度，使得你可以在同一时间只关注一件事。如果对一个模块的使用要求你同时关注好几件事——其内部工作的细节、对全局数据的修改、不确定的功能点等——那么久失去了抽象的能力，模块所具有的管理复杂度的能力也削弱或完全丧失了。类和子程序是用于降低复杂度的首选和最重要的智力工具。
